## 快速幂 Exponentiation by squaring

快速幂通过O(logn)的时间复杂度计算乘方，十分常用

### 场景

让我们思考下，如何快速计算 2的10次方？

方法1: 最直观的方法就是 2*2*2*2*... 一次相乘下去，一共会计算10次；<br/>
这样虽然直观，但是太慢了，或许我们可以拆分下问题；

方法2: 先计算 2的5次方(2*2*2*2*2，一共计算4次)，计算结果再计算平方；<br/>
总共计算了5次，但这也不是最优的路径；

方法3: 先计算 2的平方(2*2=4)，然后计算 2的5次方(4*4*2)，最后计算平方；<br/>
这种方式是最快的，只需要计算4次；

通过这种 `二分法` 的方式，我们就可以在O(logn)时间内计算出幂；

### 伪代码

递归方式：

```javascript
function quickPow(a, n) {
  if (n == 0) {
    return 1;
  } else if (n % 2 == 1) {
    return quickPow(a, n - 1) * a;
  } else {
    const temp = quickPow(a, n / 2);
    return temp * temp;
  }
}
```

在实际的场景中，幂计算得到的结果会很大，通常需要我们对结果进行取模，所以我们快速幂计算中也需要进行取模，而且是 **步步取模**；

```javascript
const MOD = 1000000007;
function quickPow(a, n) {
  if (n == 0) {
    return 1;
  } else if (n % 2 == 1) {
    return quickPow(a, n - 1) * a % MOD;
  } else {
    const temp = quickPow(a, n / 2) % MOD;
    return temp * temp % MOD;
  }
}
```

递归的算法虽然简洁，但是会产生额外的空间消耗，我们可以将其替换为更简单的循环；

```javascript
function quickPow(a, n){
  let ans = 1;
  while(n) {
    if(n & 1) ans = ans * a;
    a = a * a;
    n = n >> 1;
  }
  return ans;
}
```
