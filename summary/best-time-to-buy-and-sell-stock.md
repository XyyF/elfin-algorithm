# 股票买卖的最佳时机

## 推导

推导思路：穷举
```js
利用 [状态] 进行穷举，将所有的可能性列举出
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)

```

### 状态

股票问题状态有3种
- 天数：第i天

- 当天操作后允许交易的最大次数：K

  其实对于最大可交易次数，大部分场景都是限制了1次交易 || 不限制交易次数

- 当天的持有状态：持有股票1、未持有股票0

```js
dp[i][k][0 or 1]
0 <= i <= n-1, 1 <= k <= K
n 为天数，大 K 为最多交易数
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)

例如：
dp[3][2][1]: 今天是第3天，我手上持有股票，还可至多交易2次，至此我获得的收益
dp[3][2][0]: 今天是第3天，我手上没有持有股票，还可至多交易2次，至此我获得的收益
收益说明：当天股票价格prices[i]：💰
前一天未持有 <-> 今天持有：说明我买入了股票，那么我将付出当天股票价格的💰，收益 - 💰
前一天持有 <-> 今天未持有：说明我卖了股票了，那么我将获得当天股票价格的💰，收益 + 💰
		**真实收益其实就是 买卖股票时价格的差值**
前一天持有 <-> 今天持有：说明我没有操作，那么我的收益将不会改变
前一天未持有 <-> 今天未持有：说明我没有操作，那么我的收益将不会改变
```

### 状态转移方程

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghravyqc89j30m20efaa6.jpg)

```js
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
							max(前一天未持有股票, 前一天持有股票)
              max(选择 rest, 选择 sell)

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k+1][0] - prices[i])
							max(前一天持有股票, 前一天未持有股票)
              max(选择 rest, 选择 buy)
```

### base case

```js
dp[0][K][0] = 0 因为我没有买入股票
dp[0][K + 1][1] = -prices[0] 第一天买入了股票

dp[i][maxK][0] = max(dp[i - 1][0][0], dp[i - 1][-1][1] + prices[i]) = 0
```

### 最优解

```js
dp[i][K][0] 即最后一天时，我手上没有持有股票所得的最大收益(相较于持有，未持有的收益肯定最大
```

## 优化

可以从状态转移方程看出，整个流程其实只需要几个变量即可

```js
dp[i][k][0]
dp[i][k][1]
dp[i - 1][k][0]
dp[i - 1][k][1]
dp[i - 1][k - 1][0]

在某些場景下，K值可以被优化，所以就可以使用变量来递归，而不是多维数组
```

## 相关题目
[123.best-time-to-buy-adn-sell-stock-iii]()