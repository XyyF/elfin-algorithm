# 插入排序 Insertion Sort

## 前置思考

> 在一组有序的列表中，插入一个元素，让结果保持有序，该如何操作？

因为列表是有序的，所以首先找到插入的位置，然后将元素后的节点从末尾开始依次后移一位，再将元素赋值

```js
1  7  8  3

1 [ ] 7  8  3

1  6  7  8  3

// 以这种方式，从末尾开始实现元素后移
arr[j + 1] = arr[j];
...
// 再将元素插入到特定的位置
arr[i] = element;
```

## 插入排序

插入排序 将列表分为了两个部分，分别是 【已排区域】和 【未排区域】

初始状态，已排区域就是列表的第一个元素，未排区域就是身下的元素；再依次将未排区域中的元素插入到已排区域中。

```js
初始顺序: 4 | 5 6 1 3 2
插入排序: 4 5 | 6 1 3 2
插入排序: 4 5 6 | 1 3 2
...
最终结果: 1 2 3 4 5 6 |
```

## 代码实现

```js
function insertionSort(list) {
  const l = list.length;
  for (let i = 1; i < l; i++) {
    const value = list[i];

    // 考虑 -1 是因为存在首端插入的场景
    for (let j = i - 1; j >= -1; j--) {

      if (list[j] > value) {
        // 移动数据
        list[j + 1] = list[j];
      } else {
        // 插入数据
        list[j + 1] = value;  
        break;
      }

    }
  }
}
```

## 算法分析

### 第一. 是否是原地算法
插入过程中只有转移元素的位置，空间复杂度为O(1)，是原地算法

### 第二. 是否是稳定的排序算法
插入过程中，只有值不同的时候才会交换，当值相同时，元素间不会交换顺序，是稳定的排序算法

### 第三. 空间复杂度如何
最坏的情况下，两次for循环，时间复杂度为O(n^2)

### 对比
插入排序 和 冒泡排序 的特点十分相似，那么如何抉择呢？

在冒泡排序中，每次交换两个元素，将会进行3次赋值
```js
const temp = list[i];
list[i] = list[i + 1];
list[i + 1] = temp; 
```

在插入排序中，转移元素，则很简便
```js
list[i + 1] = list[i]
```

## 希尔排序
TODO